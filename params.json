{"name":"Linux, ARM and QEMU","tagline":"Script for compiling Linux, BusyBox for AMR and running it on QEMU.","body":"##0. Introduction\r\n  Following is a writeup on how to compile Linux kernel& \r\n  BusyBox for ARM architecture and to load a simple device driver on the emulated system.\r\n##### Prerequisites\r\n        Ubuntu Linux machine with build utils and build essentials like make etc.\r\n        Working internet Connection.\r\n        \r\n  >The Shell script **myEmu.sh** in my repository automates the below outlined process \r\n  >and boots up a linux kernel running on ARM processor (of course this \r\n  >is NOT a silent run, passwords have to be entered and menuconfigs configured).\r\n        \r\n##1. Compiling Linux from Source for ARM architecture\r\n#####Get Linux Kernel source\r\n        wget https://www.kernel.org/pub/linux/kernel/v3.0/linux-3.10.tar.bz2\r\n#####Get cross compilation tool-chain for ARM architecture\r\n        sudo apt-get install gcc-arm-linux-gnueabi\r\n#####Extract the linux source from the Gzipped tarball\r\n        tar xjvf linux-3.10.tar.bz2\r\n\r\n#####Set environment variables to tell the Linux Build system to build for ARM and use a specific cross-compiler.\r\n        export ARCH=arm\r\n        export CROSS_COMPILE=arm-linux-gnueabi-\r\n  >Note the hyphen at the end, the **CROSS_COMPILE** env \r\n  >variable is a prefix added to the default compiler to get the cross compiler.\r\n    \r\n#####Configure Linux Build system to compile for the versatile express family of boards.\r\n        cd linux-3.10\r\n        make vexpress_defconfig\r\n  >This creates a _.config_ hidden file containing all the build configurations.\r\n\r\n#####Actually Build the Linux Kernel Code\r\n        make -j 4 all\r\n  >The -j 4 option is to enable parallelism during compilation.\r\n  >Once the Build is Complete, the linux Kernel Image for ARM architecture \r\n  >is saved as **zImage** under **linux-3.10/arch/arm/boot/**\r\n\r\n\r\n##2. Compiling BusyBox from source for ARM architecture\r\n#####Get BusyBox source\r\n        wget http://www.busybox.net/downloads/busybox-1.21.1.tar.bz2\r\n#####Extract source from Gzipped tarball\r\n        tar xjvf busybox-1.21.1.tar.bz2\r\n#####Configure the BusyBox Build system using the default configurations.\r\n        cd busybox-1.21.1\r\n        make defconfig\r\n  >Additionally use a GUI driven build configuration settings page\r\n  >to tell BusyBox to compile everything statically and leave out \r\n  >certain unwanted and troublesome modules.\r\n\r\n        make menuconfig\r\n  >Traverse in the GUI\r\n######Busybox Settings ==> Build Options \r\n######SELECT Build BusyBox as a static binary(no shared libs)\r\n######Network Utilities==> Omit the Setup RPC Utilities (Optional, compiling with RPC might fail on some systems.\r\n  >If you are getting an error that __curses.h__ is missing \r\n  >install ncurses-dev package.\r\n\r\n        sudo apt-get install libncurses5-dev\r\n        \r\n#####Actually Build BusyBox Code\r\n        make -j 4 install\r\n  >Once the build is complete, a folder named **_install** is created. \r\n  >This folder contains a bare structure of the linux root file system. \r\n  >As you can see some important folder like proc, dev, sys etc are missing. \r\n  >So lets go ahead and create them.\r\n        \r\n        cd _install\r\n        mkdir proc sys dev etc etc/init.d\r\n  >It is not enough that we just create the special directories, we have \r\n  >to tell the kernel to mount special services to their respective directories.\r\n  \r\n#####Create etc/init.d/rcS file and enter the following shell code\r\n```shell\r\n#!/bin/sh\r\nmount -t proc none /proc\r\nmount -t sysfs none /sys\r\n/sbin/mdev -s\r\n```\r\n  >/sbin/init is usually the first program run by the linux kernel and \r\n  >its default behaviour is to execute the **/etc/init.d/rcS** file.\r\n\r\n#####Mark rcS file as executable\r\n        chmod +x etc/init.d/rcS  \r\n\r\n#####Copy our Custom Memory Device Driver to filesystem (Optional)\r\n  >Since we are planning to install our simple memory driver on the emulated ARM Linux system, \r\n  >copy the driver files to any folder in this location, preferably create a new one.\r\n#####Copy Driver *.ko to a new folder, memDriver\r\n        mkdir memDrive/\r\n        cp <path to driver files> memDriver/\r\n\r\n#####Create the root filesystem image with the cpio tool.\r\n        find . | cpio -o --format=newc > ../rootfs.img\r\n  >The root FileSystem should be create by the name **rootfs.img** \r\n  >inside the **busybox-1.21.1** folder.\r\n\r\n\r\n##3. Running Linux with BusyBox on Linux for ARM on QEMU\r\n#####Installing QEMU\r\n        sudo apt-get install qemu\r\n#####Start QEMU for ARM using our custom, Kernel and BusyBox.\r\n        qemu-system-arm -M vexpress-a9 -m 256M -kernel linux-3.10/arch/arm/boot/zImage -initrd busybox-1.21.1/rootfs.img -append \"root=/dev/ram rdinit=/sbin/init\"\r\n  >A QEMU window should open up with kernel initialization messages \r\n  >and finally a message asking, *press Enter to activate console*. \r\n  >When you hit enter a root prompt is received and now you are running \r\n  >**Linux Kernel on an emulated ARM processor.**\r\n\r\n\r\n##4. Loading a Memory Driver on the QEMU Installation (Optional)\r\n#####Create a character device file with Major Number as 60 and minor number as 0.\r\n        mknod /dev/mymem c 60 0\r\n#####Insert our driver module into the kernel.\r\n        cd memDriver/\r\n        insmod memory.ko\r\n  >printk messages in module_init function should be now seen in **dmesg|tail**\r\n  >This should enable us to now read/write a single byte of data from/to memory.\r\n        \r\n#####Write to device\r\n    echo -n 4 > /dev/mymem\r\n#####Read from device\r\n    cat /dev/mymem\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}